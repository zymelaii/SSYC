# 总体设计

1. Preprocessor
2. Context-free Lexer
3. Parser
4. Compile-time handler
5. AST-MIR translator
6. Pass manager
7. Backend dispatcher
8. MIR-Assembly translator
9. Machine-dependent optimizer
10. Assembler
11. Linker

## Context-free Lexer

词法分析器的关键设计为`前缀候选链`与`状态栈`。

对于同一前缀可能存在多个可选的 token，部分情况可以通过完全匹配排除无效，但仍然存在多个 token 对于词法规则皆合法的情况。

若给定的词法规则存在以上情况，则此处称该词法是二义的。

此时，词法解析器输出的将不再是线性的 token 流，而是一棵 token 树。

在 `slimec` 的词法阶段，相较于否认该情况的合法性，`slimec` 认为其是合理且正确的。

目标语言的上下文相关性使得词法解析器无法在词法解析阶段确定文法规则所需要的 token，为了确保各环节解耦，`slimec` 选择保留词法解析器的这种**特性**，并将目标 token 的选择延迟到语法解析阶段。

而用于解决这一问题的正是`前缀候选链`。

`前缀候选链`是一个非常通俗的东西，它维护了一个单字符前缀引导的所有可能 token。

当需要读入新的 token 时，词法解析器将读入下一个字符并构造可能 token 的集合。接下来，解析器将按照一定的顺序从候选链中取出 token 并尝试读入，若失败，则表明该 token 是可以通过完全匹配排除的项，否则则是一个可选的二义 token 项。

当 token 被读入时，将递给 token 的消费者（此处即语法解析器），由其决定采纳或是拒绝该 token。

若 token 被接受，则将重置候选链并预备读取下一格 token；否则则将尝试读入下一个候选 token。

当候选链为空而 token 仍未被采纳时，即表明原文违反了词法规则或语法规则（可由 token 被拒绝的阶段判断）。

在这一过程中，词法解析器将进行 token 的试读。该过程通常是消耗性的，单项不可逆的，故引入`状态栈`来实现词法解析器状态的回溯。

`状态栈`的实质是输入缓冲与输入游标的组合，其通过缓存试读消耗的字符与产生的 token，依靠输入游标实现输入的重定向。

当 token 被拒绝或接受时，输入游标与输入缓冲将被刷新回溯至试读之前的状态。

另一个值得注意的是，语法解析器可能十分明确下一个 token，在这种情况下，候选链将只产生期望的一项 token，后续处理则与其他情况保持一致。

还有一个问题是，由于文法的限制，语法解析阶段仍可能产生二义性而无法确定 token 的采纳，在该情况下允许从词法解析器前看 token 以确定语法解析。此时的前看 token 将在假设试读 token 被采纳的基础上获取，这也就是说，前看 token 仍受`状态栈`的支配。

需要注意的是，前看 token 可能仍具备二义性，为了避免设计的复杂性，`slimec` 的词法解析器将直接将该种情况断言为错误，也即前看的 token 必须是确定的。
